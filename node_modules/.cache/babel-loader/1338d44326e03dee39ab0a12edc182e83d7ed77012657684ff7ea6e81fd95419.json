{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * It can only be used with `workbox-strategy` instances that have a\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n * In other words, it can't be used to expire entries in strategy that uses the\n * default runtime cache name.\n *\n * Whenever a cached response is used or updated, this plugin will look\n * at the associated cache and remove any old or extra responses.\n *\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached response has been used. If the response has a \"Date\" header, then\n * a light weight expiration check is performed and the response will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof workbox-expiration\n */\nclass ExpirationPlugin {\n  /**\n   * @param {ExpirationPluginOptions} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n   * that will be used when calling `delete()` on the cache.\n   * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n   * automatic deletion if the available storage quota has been exceeded.\n   */\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when a `Response` is about to be returned\n     * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n     * the handler. It allows the `Response` to be inspected for freshness and\n     * prevents it from being used if the `Response`'s `Date` header value is\n     * older than the configured `maxAgeSeconds`.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache the response is in.\n     * @param {Response} options.cachedResponse The `Response` object that's been\n     *     read from a cache and whose freshness should be checked.\n     * @return {Response} Either the `cachedResponse`, if it's\n     *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n     *\n     * @private\n     */\n    this.cachedResponseWillBeUsed = async _ref => {\n      let {\n        event,\n        request,\n        cacheName,\n        cachedResponse\n      } = _ref;\n      if (!cachedResponse) {\n        return null;\n      }\n      const isFresh = this._isResponseDateFresh(cachedResponse);\n      // Expire entries to ensure that even if the expiration date has\n      // expired, it'll only be used once.\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n      dontWaitFor(cacheExpiration.expireEntries());\n      // Update the metadata for the request URL to the current timestamp,\n      // but don't `await` it as we don't want to block the response.\n      const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n      if (event) {\n        try {\n          event.waitUntil(updateTimestampDone);\n        } catch (error) {\n          if (process.env.NODE_ENV !== 'production') {\n            // The event may not be a fetch event; only log the URL if it is.\n            if ('request' in event) {\n              logger.warn(\"Unable to ensure service worker stays alive when \" + \"updating cache entry for \" + \"'\".concat(getFriendlyURL(event.request.url), \"'.\"));\n            }\n          }\n        }\n      }\n      return isFresh ? cachedResponse : null;\n    };\n    /**\n     * A \"lifecycle\" callback that will be triggered automatically by the\n     * `workbox-strategies` handlers when an entry is added to a cache.\n     *\n     * @param {Object} options\n     * @param {string} options.cacheName Name of the cache that was updated.\n     * @param {string} options.request The Request for the cached entry.\n     *\n     * @private\n     */\n    this.cacheDidUpdate = async _ref2 => {\n      let {\n        cacheName,\n        request\n      } = _ref2;\n      if (process.env.NODE_ENV !== 'production') {\n        assert.isType(cacheName, 'string', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'cacheName'\n        });\n        assert.isInstance(request, Request, {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'cacheDidUpdate',\n          paramName: 'request'\n        });\n      }\n      const cacheExpiration = this._getCacheExpiration(cacheName);\n      await cacheExpiration.updateTimestamp(request.url);\n      await cacheExpiration.expireEntries();\n    };\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor'\n        });\n      }\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries'\n        });\n      }\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-expiration',\n          className: 'Plugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds'\n        });\n      }\n    }\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n    if (config.purgeOnQuotaError) {\n      registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n    }\n  }\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    if (cacheName === cacheNames.getRuntimeName()) {\n      throw new WorkboxError('expire-custom-caches-only');\n    }\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n  }\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number|null}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    if (!cachedResponse.headers.has('date')) {\n      return null;\n    }\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n    return headerTime;\n  }\n  /**\n   * This is a helper method that performs two operations:\n   *\n   * - Deletes *all* the underlying Cache instances associated with this plugin\n   * instance, by calling caches.delete() on your behalf.\n   * - Deletes the metadata from IndexedDB used to keep track of expiration\n   * details for each Cache instance.\n   *\n   * When using cache expiration, calling this method is preferable to calling\n   * `caches.delete()` directly, since this will ensure that the IndexedDB\n   * metadata is also cleanly removed and open IndexedDB instances are deleted.\n   *\n   * Note that if you're *not* using cache expiration for a given cache, calling\n   * `caches.delete()` and passing in the cache's name should be sufficient.\n   * There is no Workbox-specific method needed for cleanup in that case.\n   */\n  async deleteCacheAndMetadata() {\n    // Do this one at a time instead of all at once via `Promise.all()` to\n    // reduce the chance of inconsistency if a promise rejects.\n    for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n      await self.caches.delete(cacheName);\n      await cacheExpiration.delete();\n    }\n    // Reset this._cacheExpirations to its initial state.\n    this._cacheExpirations = new Map();\n  }\n}\nexport { ExpirationPlugin };","map":{"version":3,"names":["assert","cacheNames","dontWaitFor","getFriendlyURL","logger","registerQuotaErrorCallback","WorkboxError","CacheExpiration","ExpirationPlugin","constructor","config","arguments","length","undefined","cachedResponseWillBeUsed","_ref","event","request","cacheName","cachedResponse","isFresh","_isResponseDateFresh","cacheExpiration","_getCacheExpiration","expireEntries","updateTimestampDone","updateTimestamp","url","waitUntil","error","process","env","NODE_ENV","warn","concat","cacheDidUpdate","_ref2","isType","moduleName","className","funcName","paramName","isInstance","Request","maxEntries","maxAgeSeconds","_config","_maxAgeSeconds","_cacheExpirations","Map","purgeOnQuotaError","deleteCacheAndMetadata","getRuntimeName","get","set","dateHeaderTimestamp","_getDateHeaderTimestamp","now","Date","headers","has","dateHeader","parsedDate","headerTime","getTime","isNaN","self","caches","delete"],"sources":["C:/Users/meyer/Documents/careerfoundry/meet/node_modules/workbox-expiration/ExpirationPlugin.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { registerQuotaErrorCallback } from 'workbox-core/registerQuotaErrorCallback.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { CacheExpiration } from './CacheExpiration.js';\nimport './_version.js';\n/**\n * This plugin can be used in a `workbox-strategy` to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * It can only be used with `workbox-strategy` instances that have a\n * [custom `cacheName` property set](/web/tools/workbox/guides/configure-workbox#custom_cache_names_in_strategies).\n * In other words, it can't be used to expire entries in strategy that uses the\n * default runtime cache name.\n *\n * Whenever a cached response is used or updated, this plugin will look\n * at the associated cache and remove any old or extra responses.\n *\n * When using `maxAgeSeconds`, responses may be used *once* after expiring\n * because the expiration clean up will not have occurred until *after* the\n * cached response has been used. If the response has a \"Date\" header, then\n * a light weight expiration check is performed and the response will not be\n * used immediately.\n *\n * When using `maxEntries`, the entry least-recently requested will be removed\n * from the cache first.\n *\n * @memberof workbox-expiration\n */\nclass ExpirationPlugin {\n    /**\n     * @param {ExpirationPluginOptions} config\n     * @param {number} [config.maxEntries] The maximum number of entries to cache.\n     * Entries used the least will be removed as the maximum is reached.\n     * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n     * it's treated as stale and removed.\n     * @param {Object} [config.matchOptions] The [`CacheQueryOptions`](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete#Parameters)\n     * that will be used when calling `delete()` on the cache.\n     * @param {boolean} [config.purgeOnQuotaError] Whether to opt this cache in to\n     * automatic deletion if the available storage quota has been exceeded.\n     */\n    constructor(config = {}) {\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when a `Response` is about to be returned\n         * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n         * the handler. It allows the `Response` to be inspected for freshness and\n         * prevents it from being used if the `Response`'s `Date` header value is\n         * older than the configured `maxAgeSeconds`.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache the response is in.\n         * @param {Response} options.cachedResponse The `Response` object that's been\n         *     read from a cache and whose freshness should be checked.\n         * @return {Response} Either the `cachedResponse`, if it's\n         *     fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n         *\n         * @private\n         */\n        this.cachedResponseWillBeUsed = async ({ event, request, cacheName, cachedResponse, }) => {\n            if (!cachedResponse) {\n                return null;\n            }\n            const isFresh = this._isResponseDateFresh(cachedResponse);\n            // Expire entries to ensure that even if the expiration date has\n            // expired, it'll only be used once.\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            dontWaitFor(cacheExpiration.expireEntries());\n            // Update the metadata for the request URL to the current timestamp,\n            // but don't `await` it as we don't want to block the response.\n            const updateTimestampDone = cacheExpiration.updateTimestamp(request.url);\n            if (event) {\n                try {\n                    event.waitUntil(updateTimestampDone);\n                }\n                catch (error) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // The event may not be a fetch event; only log the URL if it is.\n                        if ('request' in event) {\n                            logger.warn(`Unable to ensure service worker stays alive when ` +\n                                `updating cache entry for ` +\n                                `'${getFriendlyURL(event.request.url)}'.`);\n                        }\n                    }\n                }\n            }\n            return isFresh ? cachedResponse : null;\n        };\n        /**\n         * A \"lifecycle\" callback that will be triggered automatically by the\n         * `workbox-strategies` handlers when an entry is added to a cache.\n         *\n         * @param {Object} options\n         * @param {string} options.cacheName Name of the cache that was updated.\n         * @param {string} options.request The Request for the cached entry.\n         *\n         * @private\n         */\n        this.cacheDidUpdate = async ({ cacheName, request, }) => {\n            if (process.env.NODE_ENV !== 'production') {\n                assert.isType(cacheName, 'string', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'cacheName',\n                });\n                assert.isInstance(request, Request, {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'cacheDidUpdate',\n                    paramName: 'request',\n                });\n            }\n            const cacheExpiration = this._getCacheExpiration(cacheName);\n            await cacheExpiration.updateTimestamp(request.url);\n            await cacheExpiration.expireEntries();\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new WorkboxError('max-entries-or-age-required', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                });\n            }\n            if (config.maxEntries) {\n                assert.isType(config.maxEntries, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxEntries',\n                });\n            }\n            if (config.maxAgeSeconds) {\n                assert.isType(config.maxAgeSeconds, 'number', {\n                    moduleName: 'workbox-expiration',\n                    className: 'Plugin',\n                    funcName: 'constructor',\n                    paramName: 'config.maxAgeSeconds',\n                });\n            }\n        }\n        this._config = config;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._cacheExpirations = new Map();\n        if (config.purgeOnQuotaError) {\n            registerQuotaErrorCallback(() => this.deleteCacheAndMetadata());\n        }\n    }\n    /**\n     * A simple helper method to return a CacheExpiration instance for a given\n     * cache name.\n     *\n     * @param {string} cacheName\n     * @return {CacheExpiration}\n     *\n     * @private\n     */\n    _getCacheExpiration(cacheName) {\n        if (cacheName === cacheNames.getRuntimeName()) {\n            throw new WorkboxError('expire-custom-caches-only');\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    /**\n     * @param {Response} cachedResponse\n     * @return {boolean}\n     *\n     * @private\n     */\n    _isResponseDateFresh(cachedResponse) {\n        if (!this._maxAgeSeconds) {\n            // We aren't expiring by age, so return true, it's fresh\n            return true;\n        }\n        // Check if the 'date' header will suffice a quick expiration check.\n        // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n        // discussion.\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            // Unable to parse date, so assume it's fresh.\n            return true;\n        }\n        // If we have a valid headerTime, then our response is fresh iff the\n        // headerTime plus maxAgeSeconds is greater than the current time.\n        const now = Date.now();\n        return dateHeaderTimestamp >= now - this._maxAgeSeconds * 1000;\n    }\n    /**\n     * This method will extract the data header and parse it into a useful\n     * value.\n     *\n     * @param {Response} cachedResponse\n     * @return {number|null}\n     *\n     * @private\n     */\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has('date')) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get('date');\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        // If the Date header was invalid for some reason, parsedDate.getTime()\n        // will return NaN.\n        if (isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    /**\n     * This is a helper method that performs two operations:\n     *\n     * - Deletes *all* the underlying Cache instances associated with this plugin\n     * instance, by calling caches.delete() on your behalf.\n     * - Deletes the metadata from IndexedDB used to keep track of expiration\n     * details for each Cache instance.\n     *\n     * When using cache expiration, calling this method is preferable to calling\n     * `caches.delete()` directly, since this will ensure that the IndexedDB\n     * metadata is also cleanly removed and open IndexedDB instances are deleted.\n     *\n     * Note that if you're *not* using cache expiration for a given cache, calling\n     * `caches.delete()` and passing in the cache's name should be sufficient.\n     * There is no Workbox-specific method needed for cleanup in that case.\n     */\n    async deleteCacheAndMetadata() {\n        // Do this one at a time instead of all at once via `Promise.all()` to\n        // reduce the chance of inconsistency if a promise rejects.\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations) {\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        // Reset this._cacheExpirations to its initial state.\n        this._cacheExpirations = new Map();\n    }\n}\nexport { ExpirationPlugin };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}