{"ast":null,"code":"/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * The Router can be used to process a `FetchEvent` using one or more\n * {@link workbox-routing.Route}, responding with a `Response` if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox-routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    this._routes = new Map();\n    this._defaultHandlerMap = new Map();\n  }\n  /**\n   * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n   * method name ('GET', etc.) to an array of all the corresponding `Route`\n   * instances that are registered.\n   */\n  get routes() {\n    return this._routes;\n  }\n  /**\n   * Adds a fetch event listener to respond to events when a route matches\n   * the event's request.\n   */\n  addFetchListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('fetch', event => {\n      const {\n        request\n      } = event;\n      const responsePromise = this.handleRequest({\n        request,\n        event\n      });\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n  /**\n   * Adds a message event listener for URLs to cache from the window.\n   * This is useful to cache resources loaded on the page prior to when the\n   * service worker started controlling it.\n   *\n   * The format of the message data sent from the window should be as follows.\n   * Where the `urlsToCache` array may consist of URL strings or an array of\n   * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n   *\n   * ```\n   * {\n   *   type: 'CACHE_URLS',\n   *   payload: {\n   *     urlsToCache: [\n   *       './script1.js',\n   *       './script2.js',\n   *       ['./script3.js', {mode: 'no-cors'}],\n   *     ],\n   *   },\n   * }\n   * ```\n   */\n  addCacheListener() {\n    // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n    self.addEventListener('message', event => {\n      // event.data is type 'any'\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (event.data && event.data.type === 'CACHE_URLS') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const {\n          payload\n        } = event.data;\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\"Caching URLs from the window\", payload.urlsToCache);\n        }\n        const requestPromises = Promise.all(payload.urlsToCache.map(entry => {\n          if (typeof entry === 'string') {\n            entry = [entry];\n          }\n          const request = new Request(...entry);\n          return this.handleRequest({\n            request,\n            event\n          });\n          // TODO(philipwalton): TypeScript errors without this typecast for\n          // some reason (probably a bug). The real type here should work but\n          // doesn't: `Array<Promise<Response> | undefined>`.\n        })); // TypeScript\n        event.waitUntil(requestPromises);\n        // If a MessageChannel was used, reply to the message on success.\n        if (event.ports && event.ports[0]) {\n          void requestPromises.then(() => event.ports[0].postMessage(true));\n        }\n      }\n    });\n  }\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {Object} options\n   * @param {Request} options.request The request to handle.\n   * @param {ExtendableEvent} options.event The event that triggered the\n   *     request.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   *     registered route can handle the request. If there is no matching\n   *     route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest(_ref) {\n    let {\n      request,\n      event\n    } = _ref;\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'options.request'\n      });\n    }\n    const url = new URL(request.url, location.href);\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\"Workbox Router only supports URLs that start with 'http'.\");\n      }\n      return;\n    }\n    const sameOrigin = url.origin === location.origin;\n    const {\n      params,\n      route\n    } = this.findMatchingRoute({\n      event,\n      request,\n      sameOrigin,\n      url\n    });\n    let handler = route && route.handler;\n    const debugMessages = [];\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([\"Found a route to handle this request:\", route]);\n        if (params) {\n          debugMessages.push([\"Passing the following params to the route's handler:\", params]);\n        }\n      }\n    }\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    const method = request.method;\n    if (!handler && this._defaultHandlerMap.has(method)) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(\"Failed to find a matching route. Falling \" + \"back to the default handler for \".concat(method, \".\"));\n      }\n      handler = this._defaultHandlerMap.get(method);\n    }\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(\"No route found for: \".concat(getFriendlyURL(url)));\n      }\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(\"Router is responding to: \".concat(getFriendlyURL(url)));\n      debugMessages.forEach(msg => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n      logger.groupEnd();\n    }\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({\n        url,\n        request,\n        event,\n        params\n      });\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n    // Get route's catch handler, if it exists\n    const catchHandler = route && route.catchHandler;\n    if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n      responsePromise = responsePromise.catch(async err => {\n        // If there's a route catch handler, process that first\n        if (catchHandler) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to route's Catch Handler.\"));\n            logger.error(\"Error thrown by:\", route);\n            logger.error(err);\n            logger.groupEnd();\n          }\n          try {\n            return await catchHandler.handle({\n              url,\n              request,\n              event,\n              params\n            });\n          } catch (catchErr) {\n            if (catchErr instanceof Error) {\n              err = catchErr;\n            }\n          }\n        }\n        if (this._catchHandler) {\n          if (process.env.NODE_ENV !== 'production') {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger.groupCollapsed(\"Error thrown when responding to: \" + \" \".concat(getFriendlyURL(url), \". Falling back to global Catch Handler.\"));\n            logger.error(\"Error thrown by:\", route);\n            logger.error(err);\n            logger.groupEnd();\n          }\n          return this._catchHandler.handle({\n            url,\n            request,\n            event\n          });\n        }\n        throw err;\n      });\n    }\n    return responsePromise;\n  }\n  /**\n   * Checks a request and URL (and optionally an event) against the list of\n   * registered routes, and if there's a match, returns the corresponding\n   * route along with any params generated by the match.\n   *\n   * @param {Object} options\n   * @param {URL} options.url\n   * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n   *     against the current origin.\n   * @param {Request} options.request The request to match.\n   * @param {Event} options.event The corresponding event.\n   * @return {Object} An object with `route` and `params` properties.\n   *     They are populated if a matching route was found or `undefined`\n   *     otherwise.\n   */\n  findMatchingRoute(_ref2) {\n    let {\n      url,\n      sameOrigin,\n      request,\n      event\n    } = _ref2;\n    const routes = this._routes.get(request.method) || [];\n    for (const route of routes) {\n      let params;\n      // route.match returns type any, not possible to change right now.\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const matchResult = route.match({\n        url,\n        sameOrigin,\n        request,\n        event\n      });\n      if (matchResult) {\n        if (process.env.NODE_ENV !== 'production') {\n          // Warn developers that using an async matchCallback is almost always\n          // not the right thing to do.\n          if (matchResult instanceof Promise) {\n            logger.warn(\"While routing \".concat(getFriendlyURL(url), \", an async \") + \"matchCallback function was used. Please convert the \" + \"following route to use a synchronous matchCallback function:\", route);\n          }\n        }\n        // See https://github.com/GoogleChrome/workbox/issues/2079\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        params = matchResult;\n        if (Array.isArray(params) && params.length === 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          params = undefined;\n        } else if (matchResult.constructor === Object &&\n        // eslint-disable-line\n        Object.keys(matchResult).length === 0) {\n          // Instead of passing an empty object in as params, use undefined.\n          params = undefined;\n        } else if (typeof matchResult === 'boolean') {\n          // For the boolean value true (rather than just something truth-y),\n          // don't set params.\n          // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n          params = undefined;\n        }\n        // Return early if have a match.\n        return {\n          route,\n          params\n        };\n      }\n    }\n    // If no match was found above, return and empty object.\n    return {};\n  }\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to associate with this\n   * default handler. Each method has its own default.\n   */\n  setDefaultHandler(handler) {\n    let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMethod;\n    this._defaultHandlerMap.set(method, normalizeHandler(handler));\n  }\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox-routing~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox-routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route'\n      });\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler'\n      });\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method'\n      });\n    }\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox-routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError('unregister-route-but-not-found-with-method', {\n        method: route.method\n      });\n    }\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n}\nexport { Router };","map":{"version":3,"names":["assert","getFriendlyURL","defaultMethod","logger","normalizeHandler","WorkboxError","Router","constructor","_routes","Map","_defaultHandlerMap","routes","addFetchListener","self","addEventListener","event","request","responsePromise","handleRequest","respondWith","addCacheListener","data","type","payload","process","env","NODE_ENV","debug","urlsToCache","requestPromises","Promise","all","map","entry","Request","waitUntil","ports","then","postMessage","_ref","isInstance","moduleName","className","funcName","paramName","url","URL","location","href","protocol","startsWith","sameOrigin","origin","params","route","findMatchingRoute","handler","debugMessages","push","method","has","concat","get","groupCollapsed","forEach","msg","Array","isArray","log","groupEnd","handle","err","reject","catchHandler","_catchHandler","catch","error","catchErr","Error","_ref2","matchResult","match","warn","length","undefined","Object","keys","setDefaultHandler","arguments","set","setCatchHandler","registerRoute","isType","hasMethod","unregisterRoute","routeIndex","indexOf","splice"],"sources":["C:/Users/meyer/Documents/careerfoundry/meet/node_modules/workbox-routing/Router.js"],"sourcesContent":["/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { defaultMethod } from './utils/constants.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { normalizeHandler } from './utils/normalizeHandler.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n/**\n * The Router can be used to process a `FetchEvent` using one or more\n * {@link workbox-routing.Route}, responding with a `Response` if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox-routing\n */\nclass Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n    }\n    /**\n     * @return {Map<string, Array<workbox-routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n    get routes() {\n        return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n    addFetchListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('fetch', ((event) => {\n            const { request } = event;\n            const responsePromise = this.handleRequest({ request, event });\n            if (responsePromise) {\n                event.respondWith(responsePromise);\n            }\n        }));\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded on the page prior to when the\n     * service worker started controlling it.\n     *\n     * The format of the message data sent from the window should be as follows.\n     * Where the `urlsToCache` array may consist of URL strings or an array of\n     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).\n     *\n     * ```\n     * {\n     *   type: 'CACHE_URLS',\n     *   payload: {\n     *     urlsToCache: [\n     *       './script1.js',\n     *       './script2.js',\n     *       ['./script3.js', {mode: 'no-cors'}],\n     *     ],\n     *   },\n     * }\n     * ```\n     */\n    addCacheListener() {\n        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705\n        self.addEventListener('message', ((event) => {\n            // event.data is type 'any'\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (event.data && event.data.type === 'CACHE_URLS') {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const { payload } = event.data;\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);\n                }\n                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {\n                    if (typeof entry === 'string') {\n                        entry = [entry];\n                    }\n                    const request = new Request(...entry);\n                    return this.handleRequest({ request, event });\n                    // TODO(philipwalton): TypeScript errors without this typecast for\n                    // some reason (probably a bug). The real type here should work but\n                    // doesn't: `Array<Promise<Response> | undefined>`.\n                })); // TypeScript\n                event.waitUntil(requestPromises);\n                // If a MessageChannel was used, reply to the message on success.\n                if (event.ports && event.ports[0]) {\n                    void requestPromises.then(() => event.ports[0].postMessage(true));\n                }\n            }\n        }));\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle.\n     * @param {ExtendableEvent} options.event The event that triggered the\n     *     request.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n    handleRequest({ request, event, }) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(request, Request, {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'handleRequest',\n                paramName: 'options.request',\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith('http')) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n            }\n            return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const { params, route } = this.findMatchingRoute({\n            event,\n            request,\n            sameOrigin,\n            url,\n        });\n        let handler = route && route.handler;\n        const debugMessages = [];\n        if (process.env.NODE_ENV !== 'production') {\n            if (handler) {\n                debugMessages.push([`Found a route to handle this request:`, route]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`,\n                        params,\n                    ]);\n                }\n            }\n        }\n        // If we don't have a handler because there was no matching route, then\n        // fall back to defaultHandler if that's defined.\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n            if (process.env.NODE_ENV !== 'production') {\n                debugMessages.push(`Failed to find a matching route. Falling ` +\n                    `back to the default handler for ${method}.`);\n            }\n            handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n            if (process.env.NODE_ENV !== 'production') {\n                // No handler so Workbox will do nothing. If logs is set of debug\n                // i.e. verbose, we should print out this information.\n                logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n            }\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            // We have a handler, meaning Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n            debugMessages.forEach((msg) => {\n                if (Array.isArray(msg)) {\n                    logger.log(...msg);\n                }\n                else {\n                    logger.log(msg);\n                }\n            });\n            logger.groupEnd();\n        }\n        // Wrap in try and catch in case the handle method throws a synchronous\n        // error. It should still callback to the catch handler.\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({ url, request, event, params });\n        }\n        catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        // Get route's catch handler, if it exists\n        const catchHandler = route && route.catchHandler;\n        if (responsePromise instanceof Promise &&\n            (this._catchHandler || catchHandler)) {\n            responsePromise = responsePromise.catch(async (err) => {\n                // If there's a route catch handler, process that first\n                if (catchHandler) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // Still include URL here as it will be async from the console group\n                        // and may not make sense without the URL\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\n                            ` ${getFriendlyURL(url)}. Falling back to route's Catch Handler.`);\n                        logger.error(`Error thrown by:`, route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    try {\n                        return await catchHandler.handle({ url, request, event, params });\n                    }\n                    catch (catchErr) {\n                        if (catchErr instanceof Error) {\n                            err = catchErr;\n                        }\n                    }\n                }\n                if (this._catchHandler) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        // Still include URL here as it will be async from the console group\n                        // and may not make sense without the URL\n                        logger.groupCollapsed(`Error thrown when responding to: ` +\n                            ` ${getFriendlyURL(url)}. Falling back to global Catch Handler.`);\n                        logger.error(`Error thrown by:`, route);\n                        logger.error(err);\n                        logger.groupEnd();\n                    }\n                    return this._catchHandler.handle({ url, request, event });\n                }\n                throw err;\n            });\n        }\n        return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {boolean} options.sameOrigin The result of comparing `url.origin`\n     *     against the current origin.\n     * @param {Request} options.request The request to match.\n     * @param {Event} options.event The corresponding event.\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n    findMatchingRoute({ url, sameOrigin, request, event, }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes) {\n            let params;\n            // route.match returns type any, not possible to change right now.\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const matchResult = route.match({ url, sameOrigin, request, event });\n            if (matchResult) {\n                if (process.env.NODE_ENV !== 'production') {\n                    // Warn developers that using an async matchCallback is almost always\n                    // not the right thing to do.\n                    if (matchResult instanceof Promise) {\n                        logger.warn(`While routing ${getFriendlyURL(url)}, an async ` +\n                            `matchCallback function was used. Please convert the ` +\n                            `following route to use a synchronous matchCallback function:`, route);\n                    }\n                }\n                // See https://github.com/GoogleChrome/workbox/issues/2079\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                params = matchResult;\n                if (Array.isArray(params) && params.length === 0) {\n                    // Instead of passing an empty array in as params, use undefined.\n                    params = undefined;\n                }\n                else if (matchResult.constructor === Object && // eslint-disable-line\n                    Object.keys(matchResult).length === 0) {\n                    // Instead of passing an empty object in as params, use undefined.\n                    params = undefined;\n                }\n                else if (typeof matchResult === 'boolean') {\n                    // For the boolean value true (rather than just something truth-y),\n                    // don't set params.\n                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353\n                    params = undefined;\n                }\n                // Return early if have a match.\n                return { route, params };\n            }\n        }\n        // If no match was found above, return and empty object.\n        return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to associate with this\n     * default handler. Each method has its own default.\n     */\n    setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {workbox-routing~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to register.\n     */\n    registerRoute(route) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isType(route, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route, 'match', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.isType(route.handler, 'object', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route',\n            });\n            assert.hasMethod(route.handler, 'handle', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.handler',\n            });\n            assert.isType(route.method, 'string', {\n                moduleName: 'workbox-routing',\n                className: 'Router',\n                funcName: 'registerRoute',\n                paramName: 'route.method',\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        // Give precedence to all of the earlier routes by adding this additional\n        // route to the end of the array.\n        this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {workbox-routing.Route} route The route to unregister.\n     */\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new WorkboxError('unregister-route-but-not-found-with-method', {\n                method: route.method,\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        }\n        else {\n            throw new WorkboxError('unregister-route-route-not-registered');\n        }\n    }\n}\nexport { Router };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,iCAAiC;AACxD,SAASC,cAAc,QAAQ,yCAAyC;AACxE,SAASC,aAAa,QAAQ,sBAAsB;AACpD,SAASC,MAAM,QAAQ,iCAAiC;AACxD,SAASC,gBAAgB,QAAQ,6BAA6B;AAC9D,SAASC,YAAY,QAAQ,uCAAuC;AACpE,OAAO,eAAe;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,MAAM,CAAC;EACT;AACJ;AACA;EACIC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;IACxB,IAAI,CAACC,kBAAkB,GAAG,IAAID,GAAG,CAAC,CAAC;EACvC;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIE,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACH,OAAO;EACvB;EACA;AACJ;AACA;AACA;EACII,gBAAgBA,CAAA,EAAG;IACf;IACAC,IAAI,CAACC,gBAAgB,CAAC,OAAO,EAAIC,KAAK,IAAK;MACvC,MAAM;QAAEC;MAAQ,CAAC,GAAGD,KAAK;MACzB,MAAME,eAAe,GAAG,IAAI,CAACC,aAAa,CAAC;QAAEF,OAAO;QAAED;MAAM,CAAC,CAAC;MAC9D,IAAIE,eAAe,EAAE;QACjBF,KAAK,CAACI,WAAW,CAACF,eAAe,CAAC;MACtC;IACJ,CAAE,CAAC;EACP;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIG,gBAAgBA,CAAA,EAAG;IACf;IACAP,IAAI,CAACC,gBAAgB,CAAC,SAAS,EAAIC,KAAK,IAAK;MACzC;MACA;MACA,IAAIA,KAAK,CAACM,IAAI,IAAIN,KAAK,CAACM,IAAI,CAACC,IAAI,KAAK,YAAY,EAAE;QAChD;QACA,MAAM;UAAEC;QAAQ,CAAC,GAAGR,KAAK,CAACM,IAAI;QAC9B,IAAIG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACvCvB,MAAM,CAACwB,KAAK,iCAAiCJ,OAAO,CAACK,WAAW,CAAC;QACrE;QACA,MAAMC,eAAe,GAAGC,OAAO,CAACC,GAAG,CAACR,OAAO,CAACK,WAAW,CAACI,GAAG,CAAEC,KAAK,IAAK;UACnE,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;YAC3BA,KAAK,GAAG,CAACA,KAAK,CAAC;UACnB;UACA,MAAMjB,OAAO,GAAG,IAAIkB,OAAO,CAAC,GAAGD,KAAK,CAAC;UACrC,OAAO,IAAI,CAACf,aAAa,CAAC;YAAEF,OAAO;YAAED;UAAM,CAAC,CAAC;UAC7C;UACA;UACA;QACJ,CAAC,CAAC,CAAC,CAAC,CAAC;QACLA,KAAK,CAACoB,SAAS,CAACN,eAAe,CAAC;QAChC;QACA,IAAId,KAAK,CAACqB,KAAK,IAAIrB,KAAK,CAACqB,KAAK,CAAC,CAAC,CAAC,EAAE;UAC/B,KAAKP,eAAe,CAACQ,IAAI,CAAC,MAAMtB,KAAK,CAACqB,KAAK,CAAC,CAAC,CAAC,CAACE,WAAW,CAAC,IAAI,CAAC,CAAC;QACrE;MACJ;IACJ,CAAE,CAAC;EACP;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIpB,aAAaA,CAAAqB,IAAA,EAAsB;IAAA,IAArB;MAAEvB,OAAO;MAAED;IAAO,CAAC,GAAAwB,IAAA;IAC7B,IAAIf,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACvC1B,MAAM,CAACwC,UAAU,CAACxB,OAAO,EAAEkB,OAAO,EAAE;QAChCO,UAAU,EAAE,iBAAiB;QAC7BC,SAAS,EAAE,QAAQ;QACnBC,QAAQ,EAAE,eAAe;QACzBC,SAAS,EAAE;MACf,CAAC,CAAC;IACN;IACA,MAAMC,GAAG,GAAG,IAAIC,GAAG,CAAC9B,OAAO,CAAC6B,GAAG,EAAEE,QAAQ,CAACC,IAAI,CAAC;IAC/C,IAAI,CAACH,GAAG,CAACI,QAAQ,CAACC,UAAU,CAAC,MAAM,CAAC,EAAE;MAClC,IAAI1B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACvCvB,MAAM,CAACwB,KAAK,4DAA4D,CAAC;MAC7E;MACA;IACJ;IACA,MAAMwB,UAAU,GAAGN,GAAG,CAACO,MAAM,KAAKL,QAAQ,CAACK,MAAM;IACjD,MAAM;MAAEC,MAAM;MAAEC;IAAM,CAAC,GAAG,IAAI,CAACC,iBAAiB,CAAC;MAC7CxC,KAAK;MACLC,OAAO;MACPmC,UAAU;MACVN;IACJ,CAAC,CAAC;IACF,IAAIW,OAAO,GAAGF,KAAK,IAAIA,KAAK,CAACE,OAAO;IACpC,MAAMC,aAAa,GAAG,EAAE;IACxB,IAAIjC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACvC,IAAI8B,OAAO,EAAE;QACTC,aAAa,CAACC,IAAI,CAAC,0CAA0CJ,KAAK,CAAC,CAAC;QACpE,IAAID,MAAM,EAAE;UACRI,aAAa,CAACC,IAAI,CAAC,yDAEfL,MAAM,CACT,CAAC;QACN;MACJ;IACJ;IACA;IACA;IACA,MAAMM,MAAM,GAAG3C,OAAO,CAAC2C,MAAM;IAC7B,IAAI,CAACH,OAAO,IAAI,IAAI,CAAC9C,kBAAkB,CAACkD,GAAG,CAACD,MAAM,CAAC,EAAE;MACjD,IAAInC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACvC+B,aAAa,CAACC,IAAI,CAAC,iFAAAG,MAAA,CACoBF,MAAM,MAAG,CAAC;MACrD;MACAH,OAAO,GAAG,IAAI,CAAC9C,kBAAkB,CAACoD,GAAG,CAACH,MAAM,CAAC;IACjD;IACA,IAAI,CAACH,OAAO,EAAE;MACV,IAAIhC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACvC;QACA;QACAvB,MAAM,CAACwB,KAAK,wBAAAkC,MAAA,CAAwB5D,cAAc,CAAC4C,GAAG,CAAC,CAAE,CAAC;MAC9D;MACA;IACJ;IACA,IAAIrB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACvC;MACA;MACAvB,MAAM,CAAC4D,cAAc,6BAAAF,MAAA,CAA6B5D,cAAc,CAAC4C,GAAG,CAAC,CAAE,CAAC;MACxEY,aAAa,CAACO,OAAO,CAAEC,GAAG,IAAK;QAC3B,IAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAE;UACpB9D,MAAM,CAACiE,GAAG,CAAC,GAAGH,GAAG,CAAC;QACtB,CAAC,MACI;UACD9D,MAAM,CAACiE,GAAG,CAACH,GAAG,CAAC;QACnB;MACJ,CAAC,CAAC;MACF9D,MAAM,CAACkE,QAAQ,CAAC,CAAC;IACrB;IACA;IACA;IACA,IAAIpD,eAAe;IACnB,IAAI;MACAA,eAAe,GAAGuC,OAAO,CAACc,MAAM,CAAC;QAAEzB,GAAG;QAAE7B,OAAO;QAAED,KAAK;QAAEsC;MAAO,CAAC,CAAC;IACrE,CAAC,CACD,OAAOkB,GAAG,EAAE;MACRtD,eAAe,GAAGa,OAAO,CAAC0C,MAAM,CAACD,GAAG,CAAC;IACzC;IACA;IACA,MAAME,YAAY,GAAGnB,KAAK,IAAIA,KAAK,CAACmB,YAAY;IAChD,IAAIxD,eAAe,YAAYa,OAAO,KACjC,IAAI,CAAC4C,aAAa,IAAID,YAAY,CAAC,EAAE;MACtCxD,eAAe,GAAGA,eAAe,CAAC0D,KAAK,CAAC,MAAOJ,GAAG,IAAK;QACnD;QACA,IAAIE,YAAY,EAAE;UACd,IAAIjD,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;YACvC;YACA;YACAvB,MAAM,CAAC4D,cAAc,CAAC,0CAAAF,MAAA,CACd5D,cAAc,CAAC4C,GAAG,CAAC,6CAA0C,CAAC;YACtE1C,MAAM,CAACyE,KAAK,qBAAqBtB,KAAK,CAAC;YACvCnD,MAAM,CAACyE,KAAK,CAACL,GAAG,CAAC;YACjBpE,MAAM,CAACkE,QAAQ,CAAC,CAAC;UACrB;UACA,IAAI;YACA,OAAO,MAAMI,YAAY,CAACH,MAAM,CAAC;cAAEzB,GAAG;cAAE7B,OAAO;cAAED,KAAK;cAAEsC;YAAO,CAAC,CAAC;UACrE,CAAC,CACD,OAAOwB,QAAQ,EAAE;YACb,IAAIA,QAAQ,YAAYC,KAAK,EAAE;cAC3BP,GAAG,GAAGM,QAAQ;YAClB;UACJ;QACJ;QACA,IAAI,IAAI,CAACH,aAAa,EAAE;UACpB,IAAIlD,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;YACvC;YACA;YACAvB,MAAM,CAAC4D,cAAc,CAAC,0CAAAF,MAAA,CACd5D,cAAc,CAAC4C,GAAG,CAAC,4CAAyC,CAAC;YACrE1C,MAAM,CAACyE,KAAK,qBAAqBtB,KAAK,CAAC;YACvCnD,MAAM,CAACyE,KAAK,CAACL,GAAG,CAAC;YACjBpE,MAAM,CAACkE,QAAQ,CAAC,CAAC;UACrB;UACA,OAAO,IAAI,CAACK,aAAa,CAACJ,MAAM,CAAC;YAAEzB,GAAG;YAAE7B,OAAO;YAAED;UAAM,CAAC,CAAC;QAC7D;QACA,MAAMwD,GAAG;MACb,CAAC,CAAC;IACN;IACA,OAAOtD,eAAe;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIsC,iBAAiBA,CAAAwB,KAAA,EAAuC;IAAA,IAAtC;MAAElC,GAAG;MAAEM,UAAU;MAAEnC,OAAO;MAAED;IAAO,CAAC,GAAAgE,KAAA;IAClD,MAAMpE,MAAM,GAAG,IAAI,CAACH,OAAO,CAACsD,GAAG,CAAC9C,OAAO,CAAC2C,MAAM,CAAC,IAAI,EAAE;IACrD,KAAK,MAAML,KAAK,IAAI3C,MAAM,EAAE;MACxB,IAAI0C,MAAM;MACV;MACA;MACA,MAAM2B,WAAW,GAAG1B,KAAK,CAAC2B,KAAK,CAAC;QAAEpC,GAAG;QAAEM,UAAU;QAAEnC,OAAO;QAAED;MAAM,CAAC,CAAC;MACpE,IAAIiE,WAAW,EAAE;QACb,IAAIxD,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACvC;UACA;UACA,IAAIsD,WAAW,YAAYlD,OAAO,EAAE;YAChC3B,MAAM,CAAC+E,IAAI,CAAC,iBAAArB,MAAA,CAAiB5D,cAAc,CAAC4C,GAAG,CAAC,yEACU,iEACQ,EAAES,KAAK,CAAC;UAC9E;QACJ;QACA;QACA;QACAD,MAAM,GAAG2B,WAAW;QACpB,IAAId,KAAK,CAACC,OAAO,CAACd,MAAM,CAAC,IAAIA,MAAM,CAAC8B,MAAM,KAAK,CAAC,EAAE;UAC9C;UACA9B,MAAM,GAAG+B,SAAS;QACtB,CAAC,MACI,IAAIJ,WAAW,CAACzE,WAAW,KAAK8E,MAAM;QAAI;QAC3CA,MAAM,CAACC,IAAI,CAACN,WAAW,CAAC,CAACG,MAAM,KAAK,CAAC,EAAE;UACvC;UACA9B,MAAM,GAAG+B,SAAS;QACtB,CAAC,MACI,IAAI,OAAOJ,WAAW,KAAK,SAAS,EAAE;UACvC;UACA;UACA;UACA3B,MAAM,GAAG+B,SAAS;QACtB;QACA;QACA,OAAO;UAAE9B,KAAK;UAAED;QAAO,CAAC;MAC5B;IACJ;IACA;IACA,OAAO,CAAC,CAAC;EACb;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIkC,iBAAiBA,CAAC/B,OAAO,EAA0B;IAAA,IAAxBG,MAAM,GAAA6B,SAAA,CAAAL,MAAA,QAAAK,SAAA,QAAAJ,SAAA,GAAAI,SAAA,MAAGtF,aAAa;IAC7C,IAAI,CAACQ,kBAAkB,CAAC+E,GAAG,CAAC9B,MAAM,EAAEvD,gBAAgB,CAACoD,OAAO,CAAC,CAAC;EAClE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIkC,eAAeA,CAAClC,OAAO,EAAE;IACrB,IAAI,CAACkB,aAAa,GAAGtE,gBAAgB,CAACoD,OAAO,CAAC;EAClD;EACA;AACJ;AACA;AACA;AACA;EACImC,aAAaA,CAACrC,KAAK,EAAE;IACjB,IAAI9B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACvC1B,MAAM,CAAC4F,MAAM,CAACtC,KAAK,EAAE,QAAQ,EAAE;QAC3Bb,UAAU,EAAE,iBAAiB;QAC7BC,SAAS,EAAE,QAAQ;QACnBC,QAAQ,EAAE,eAAe;QACzBC,SAAS,EAAE;MACf,CAAC,CAAC;MACF5C,MAAM,CAAC6F,SAAS,CAACvC,KAAK,EAAE,OAAO,EAAE;QAC7Bb,UAAU,EAAE,iBAAiB;QAC7BC,SAAS,EAAE,QAAQ;QACnBC,QAAQ,EAAE,eAAe;QACzBC,SAAS,EAAE;MACf,CAAC,CAAC;MACF5C,MAAM,CAAC4F,MAAM,CAACtC,KAAK,CAACE,OAAO,EAAE,QAAQ,EAAE;QACnCf,UAAU,EAAE,iBAAiB;QAC7BC,SAAS,EAAE,QAAQ;QACnBC,QAAQ,EAAE,eAAe;QACzBC,SAAS,EAAE;MACf,CAAC,CAAC;MACF5C,MAAM,CAAC6F,SAAS,CAACvC,KAAK,CAACE,OAAO,EAAE,QAAQ,EAAE;QACtCf,UAAU,EAAE,iBAAiB;QAC7BC,SAAS,EAAE,QAAQ;QACnBC,QAAQ,EAAE,eAAe;QACzBC,SAAS,EAAE;MACf,CAAC,CAAC;MACF5C,MAAM,CAAC4F,MAAM,CAACtC,KAAK,CAACK,MAAM,EAAE,QAAQ,EAAE;QAClClB,UAAU,EAAE,iBAAiB;QAC7BC,SAAS,EAAE,QAAQ;QACnBC,QAAQ,EAAE,eAAe;QACzBC,SAAS,EAAE;MACf,CAAC,CAAC;IACN;IACA,IAAI,CAAC,IAAI,CAACpC,OAAO,CAACoD,GAAG,CAACN,KAAK,CAACK,MAAM,CAAC,EAAE;MACjC,IAAI,CAACnD,OAAO,CAACiF,GAAG,CAACnC,KAAK,CAACK,MAAM,EAAE,EAAE,CAAC;IACtC;IACA;IACA;IACA,IAAI,CAACnD,OAAO,CAACsD,GAAG,CAACR,KAAK,CAACK,MAAM,CAAC,CAACD,IAAI,CAACJ,KAAK,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;EACIwC,eAAeA,CAACxC,KAAK,EAAE;IACnB,IAAI,CAAC,IAAI,CAAC9C,OAAO,CAACoD,GAAG,CAACN,KAAK,CAACK,MAAM,CAAC,EAAE;MACjC,MAAM,IAAItD,YAAY,CAAC,4CAA4C,EAAE;QACjEsD,MAAM,EAAEL,KAAK,CAACK;MAClB,CAAC,CAAC;IACN;IACA,MAAMoC,UAAU,GAAG,IAAI,CAACvF,OAAO,CAACsD,GAAG,CAACR,KAAK,CAACK,MAAM,CAAC,CAACqC,OAAO,CAAC1C,KAAK,CAAC;IAChE,IAAIyC,UAAU,GAAG,CAAC,CAAC,EAAE;MACjB,IAAI,CAACvF,OAAO,CAACsD,GAAG,CAACR,KAAK,CAACK,MAAM,CAAC,CAACsC,MAAM,CAACF,UAAU,EAAE,CAAC,CAAC;IACxD,CAAC,MACI;MACD,MAAM,IAAI1F,YAAY,CAAC,uCAAuC,CAAC;IACnE;EACJ;AACJ;AACA,SAASC,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}