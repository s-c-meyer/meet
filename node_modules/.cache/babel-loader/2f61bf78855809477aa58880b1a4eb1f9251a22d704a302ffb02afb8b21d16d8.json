{"ast":null,"code":"/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n  /**\n   * Creates a new instance of the strategy and sets all documented option\n   * properties as public instance properties.\n   *\n   * Note: if a custom strategy class extends the base Strategy class and does\n   * not need more than these properties, it does not need to define its own\n   * constructor.\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n   * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n   * `fetch()` requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    /**\n     * Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     *\n     * @type {string}\n     */\n    this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n    /**\n     * The list\n     * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * used by this strategy.\n     *\n     * @type {Array<Object>}\n     */\n    this.plugins = options.plugins || [];\n    /**\n     * Values passed along to the\n     * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n     * of all fetch() requests made by this strategy.\n     *\n     * @type {Object}\n     */\n    this.fetchOptions = options.fetchOptions;\n    /**\n     * The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     *\n     * @type {Object}\n     */\n    this.matchOptions = options.matchOptions;\n  }\n  /**\n   * Perform a request strategy and returns a `Promise` that will resolve with\n   * a `Response`, invoking all relevant plugin callbacks.\n   *\n   * When a strategy instance is registered with a Workbox\n   * {@link workbox-routing.Route}, this method is automatically\n   * called when the route matches.\n   *\n   * Alternatively, this method can be used in a standalone `FetchEvent`\n   * listener by passing it to `event.respondWith()`.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   */\n  handle(options) {\n    const [responseDone] = this.handleAll(options);\n    return responseDone;\n  }\n  /**\n   * Similar to {@link workbox-strategies.Strategy~handle}, but\n   * instead of just returning a `Promise` that resolves to a `Response` it\n   * it will return an tuple of `[response, done]` promises, where the former\n   * (`response`) is equivalent to what `handle()` returns, and the latter is a\n   * Promise that will resolve once any promises that were added to\n   * `event.waitUntil()` as part of performing the strategy have completed.\n   *\n   * You can await the `done` promise to ensure any extra work performed by\n   * the strategy (usually caching responses) completes successfully.\n   *\n   * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n   *     properties listed below.\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   * @return {Array<Promise>} A tuple of [response, done]\n   *     promises that can be used to determine when the response resolves as\n   *     well as when the handler has completed all its work.\n   */\n  handleAll(options) {\n    // Allow for flexible options to be passed.\n    if (options instanceof FetchEvent) {\n      options = {\n        event: options,\n        request: options.request\n      };\n    }\n    const event = options.event;\n    const request = typeof options.request === 'string' ? new Request(options.request) : options.request;\n    const params = 'params' in options ? options.params : undefined;\n    const handler = new StrategyHandler(this, {\n      event,\n      request,\n      params\n    });\n    const responseDone = this._getResponse(handler, request, event);\n    const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n    // Return an array of promises, suitable for use with Promise.all().\n    return [responseDone, handlerDone];\n  }\n  async _getResponse(handler, request, event) {\n    await handler.runCallbacks('handlerWillStart', {\n      event,\n      request\n    });\n    let response = undefined;\n    try {\n      response = await this._handle(request, handler);\n      // The \"official\" Strategy subclasses all throw this error automatically,\n      // but in case a third-party Strategy doesn't, ensure that we have a\n      // consistent failure when there's no response or an error response.\n      if (!response || response.type === 'error') {\n        throw new WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        for (const callback of handler.iterateCallbacks('handlerDidError')) {\n          response = await callback({\n            error,\n            event,\n            request\n          });\n          if (response) {\n            break;\n          }\n        }\n      }\n      if (!response) {\n        throw error;\n      } else if (process.env.NODE_ENV !== 'production') {\n        logger.log(\"While responding to '\".concat(getFriendlyURL(request.url), \"', \") + \"an \".concat(error instanceof Error ? error.toString() : '', \" error occurred. Using a fallback response provided by \") + \"a handlerDidError plugin.\");\n      }\n    }\n    for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n      response = await callback({\n        event,\n        request,\n        response\n      });\n    }\n    return response;\n  }\n  async _awaitComplete(responseDone, handler, request, event) {\n    let response;\n    let error;\n    try {\n      response = await responseDone;\n    } catch (error) {\n      // Ignore errors, as response errors should be caught via the `response`\n      // promise above. The `done` promise will only throw for errors in\n      // promises passed to `handler.waitUntil()`.\n    }\n    try {\n      await handler.runCallbacks('handlerDidRespond', {\n        event,\n        request,\n        response\n      });\n      await handler.doneWaiting();\n    } catch (waitUntilError) {\n      if (waitUntilError instanceof Error) {\n        error = waitUntilError;\n      }\n    }\n    await handler.runCallbacks('handlerDidComplete', {\n      event,\n      request,\n      response,\n      error: error\n    });\n    handler.destroy();\n    if (error) {\n      throw error;\n    }\n  }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */","map":{"version":3,"names":["cacheNames","WorkboxError","logger","getFriendlyURL","StrategyHandler","Strategy","constructor","options","arguments","length","undefined","cacheName","getRuntimeName","plugins","fetchOptions","matchOptions","handle","responseDone","handleAll","FetchEvent","event","request","Request","params","handler","_getResponse","handlerDone","_awaitComplete","runCallbacks","response","_handle","type","url","error","Error","callback","iterateCallbacks","process","env","NODE_ENV","log","concat","toString","doneWaiting","waitUntilError","destroy"],"sources":["C:/Users/meyer/Documents/careerfoundry/meet/node_modules/workbox-strategies/Strategy.js"],"sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { StrategyHandler } from './StrategyHandler.js';\nimport './_version.js';\n/**\n * An abstract base class that all other strategy classes must extend from:\n *\n * @memberof workbox-strategies\n */\nclass Strategy {\n    /**\n     * Creates a new instance of the strategy and sets all documented option\n     * properties as public instance properties.\n     *\n     * Note: if a custom strategy class extends the base Strategy class and does\n     * not need more than these properties, it does not need to define its own\n     * constructor.\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of [non-navigation](https://github.com/GoogleChrome/workbox/issues/1796)\n     * `fetch()` requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     */\n    constructor(options = {}) {\n        /**\n         * Cache name to store and retrieve\n         * requests. Defaults to the cache names provided by\n         * {@link workbox-core.cacheNames}.\n         *\n         * @type {string}\n         */\n        this.cacheName = cacheNames.getRuntimeName(options.cacheName);\n        /**\n         * The list\n         * [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n         * used by this strategy.\n         *\n         * @type {Array<Object>}\n         */\n        this.plugins = options.plugins || [];\n        /**\n         * Values passed along to the\n         * [`init`]{@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters}\n         * of all fetch() requests made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.fetchOptions = options.fetchOptions;\n        /**\n         * The\n         * [`CacheQueryOptions`]{@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions}\n         * for any `cache.match()` or `cache.put()` calls made by this strategy.\n         *\n         * @type {Object}\n         */\n        this.matchOptions = options.matchOptions;\n    }\n    /**\n     * Perform a request strategy and returns a `Promise` that will resolve with\n     * a `Response`, invoking all relevant plugin callbacks.\n     *\n     * When a strategy instance is registered with a Workbox\n     * {@link workbox-routing.Route}, this method is automatically\n     * called when the route matches.\n     *\n     * Alternatively, this method can be used in a standalone `FetchEvent`\n     * listener by passing it to `event.respondWith()`.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     */\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    /**\n     * Similar to {@link workbox-strategies.Strategy~handle}, but\n     * instead of just returning a `Promise` that resolves to a `Response` it\n     * it will return an tuple of `[response, done]` promises, where the former\n     * (`response`) is equivalent to what `handle()` returns, and the latter is a\n     * Promise that will resolve once any promises that were added to\n     * `event.waitUntil()` as part of performing the strategy have completed.\n     *\n     * You can await the `done` promise to ensure any extra work performed by\n     * the strategy (usually caching responses) completes successfully.\n     *\n     * @param {FetchEvent|Object} options A `FetchEvent` or an object with the\n     *     properties listed below.\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     * @return {Array<Promise>} A tuple of [response, done]\n     *     promises that can be used to determine when the response resolves as\n     *     well as when the handler has completed all its work.\n     */\n    handleAll(options) {\n        // Allow for flexible options to be passed.\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request,\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === 'string'\n            ? new Request(options.request)\n            : options.request;\n        const params = 'params' in options ? options.params : undefined;\n        const handler = new StrategyHandler(this, { event, request, params });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        // Return an array of promises, suitable for use with Promise.all().\n        return [responseDone, handlerDone];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks('handlerWillStart', { event, request });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            // The \"official\" Strategy subclasses all throw this error automatically,\n            // but in case a third-party Strategy doesn't, ensure that we have a\n            // consistent failure when there's no response or an error response.\n            if (!response || response.type === 'error') {\n                throw new WorkboxError('no-response', { url: request.url });\n            }\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks('handlerDidError')) {\n                    response = await callback({ error, event, request });\n                    if (response) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                logger.log(`While responding to '${getFriendlyURL(request.url)}', ` +\n                    `an ${error instanceof Error ? error.toString() : ''} error occurred. Using a fallback response provided by ` +\n                    `a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks('handlerWillRespond')) {\n            response = await callback({ event, request, response });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response;\n        let error;\n        try {\n            response = await responseDone;\n        }\n        catch (error) {\n            // Ignore errors, as response errors should be caught via the `response`\n            // promise above. The `done` promise will only throw for errors in\n            // promises passed to `handler.waitUntil()`.\n        }\n        try {\n            await handler.runCallbacks('handlerDidRespond', {\n                event,\n                request,\n                response,\n            });\n            await handler.doneWaiting();\n        }\n        catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks('handlerDidComplete', {\n            event,\n            request,\n            response,\n            error: error,\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\nexport { Strategy };\n/**\n * Classes extending the `Strategy` based class should implement this method,\n * and leverage the {@link workbox-strategies.StrategyHandler}\n * arg to perform all fetching and cache logic, which will ensure all relevant\n * cache, cache options, fetch options and plugins are used (per the current\n * strategy instance).\n *\n * @name _handle\n * @instance\n * @abstract\n * @function\n * @param {Request} request\n * @param {workbox-strategies.StrategyHandler} handler\n * @return {Promise<Response>}\n *\n * @memberof workbox-strategies.Strategy\n */\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,UAAU,QAAQ,qCAAqC;AAChE,SAASC,YAAY,QAAQ,uCAAuC;AACpE,SAASC,MAAM,QAAQ,iCAAiC;AACxD,SAASC,cAAc,QAAQ,yCAAyC;AACxE,SAASC,eAAe,QAAQ,sBAAsB;AACtD,OAAO,eAAe;AACtB;AACA;AACA;AACA;AACA;AACA,MAAMC,QAAQ,CAAC;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAAA,EAAe;IAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACpB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACG,SAAS,GAAGX,UAAU,CAACY,cAAc,CAACL,OAAO,CAACI,SAAS,CAAC;IAC7D;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACE,OAAO,GAAGN,OAAO,CAACM,OAAO,IAAI,EAAE;IACpC;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAGP,OAAO,CAACO,YAAY;IACxC;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,YAAY,GAAGR,OAAO,CAACQ,YAAY;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,MAAMA,CAACT,OAAO,EAAE;IACZ,MAAM,CAACU,YAAY,CAAC,GAAG,IAAI,CAACC,SAAS,CAACX,OAAO,CAAC;IAC9C,OAAOU,YAAY;EACvB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,SAASA,CAACX,OAAO,EAAE;IACf;IACA,IAAIA,OAAO,YAAYY,UAAU,EA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}