{"ast":null,"code":"/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n  return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n  /**\n   * Creates a new instance associated with the passed strategy and event\n   * that's handling the request.\n   *\n   * The constructor also initializes the state that will be passed to each of\n   * the plugins handling this request.\n   *\n   * @param {workbox-strategies.Strategy} strategy\n   * @param {Object} options\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params] The return value from the\n   *     {@link workbox-routing~matchCallback} (if applicable).\n   */\n  constructor(strategy, options) {\n    this._cacheKeys = {};\n    /**\n     * The request the strategy is performing (passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * @name request\n     * @instance\n     * @type {Request}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * The event associated with this request.\n     * @name event\n     * @instance\n     * @type {ExtendableEvent}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * A `URL` instance of `request.url` (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `url` param will be present if the strategy was invoked\n     * from a workbox `Route` object.\n     * @name url\n     * @instance\n     * @type {URL|undefined}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    /**\n     * A `param` value (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `param` param will be present if the strategy was invoked\n     * from a workbox `Route` object and the\n     * {@link workbox-routing~matchCallback} returned\n     * a truthy value (it will be that value).\n     * @name params\n     * @instance\n     * @type {*|undefined}\n     * @memberof workbox-strategies.StrategyHandler\n     */\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(options.event, ExtendableEvent, {\n        moduleName: 'workbox-strategies',\n        className: 'StrategyHandler',\n        funcName: 'constructor',\n        paramName: 'options.event'\n      });\n    }\n    Object.assign(this, options);\n    this.event = options.event;\n    this._strategy = strategy;\n    this._handlerDeferred = new Deferred();\n    this._extendLifetimePromises = [];\n    // Copy the plugins list (since it's mutable on the strategy),\n    // so any mutations don't affect this handler instance.\n    this._plugins = [...strategy.plugins];\n    this._pluginStateMap = new Map();\n    for (const plugin of this._plugins) {\n      this._pluginStateMap.set(plugin, {});\n    }\n    this.event.waitUntil(this._handlerDeferred.promise);\n  }\n  /**\n   * Fetches a given request (and invokes any applicable plugin callback\n   * methods) using the `fetchOptions` (for non-navigation requests) and\n   * `plugins` defined on the `Strategy` object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - `requestWillFetch()`\n   * - `fetchDidSucceed()`\n   * - `fetchDidFail()`\n   *\n   * @param {Request|string} input The URL or request to fetch.\n   * @return {Promise<Response>}\n   */\n  async fetch(input) {\n    const {\n      event\n    } = this;\n    let request = toRequest(input);\n    if (request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse) {\n      const possiblePreloadResponse = await event.preloadResponse;\n      if (possiblePreloadResponse) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.log(\"Using a preloaded navigation response for \" + \"'\".concat(getFriendlyURL(request.url), \"'\"));\n        }\n        return possiblePreloadResponse;\n      }\n    }\n    // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n    const originalRequest = this.hasCallback('fetchDidFail') ? request.clone() : null;\n    try {\n      for (const cb of this.iterateCallbacks('requestWillFetch')) {\n        request = await cb({\n          request: request.clone(),\n          event\n        });\n      }\n    } catch (err) {\n      if (err instanceof Error) {\n        throw new WorkboxError('plugin-error-request-will-fetch', {\n          thrownErrorMessage: err.message\n        });\n      }\n    }\n    // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (most likely from a `fetch` event) different\n    // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n    const pluginFilteredRequest = request.clone();\n    try {\n      let fetchResponse;\n      // See https://github.com/GoogleChrome/workbox/issues/1796\n      fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' returned a response with \") + \"status '\".concat(fetchResponse.status, \"'.\"));\n      }\n      for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n        fetchResponse = await callback({\n          event,\n          request: pluginFilteredRequest,\n          response: fetchResponse\n        });\n      }\n      return fetchResponse;\n    } catch (error) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.log(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' threw an error.\"), error);\n      }\n      // `originalRequest` will only exist if a `fetchDidFail` callback\n      // is being used (see above).\n      if (originalRequest) {\n        await this.runCallbacks('fetchDidFail', {\n          error: error,\n          event,\n          originalRequest: originalRequest.clone(),\n          request: pluginFilteredRequest.clone()\n        });\n      }\n      throw error;\n    }\n  }\n  /**\n   * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n   * the response generated by `this.fetch()`.\n   *\n   * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n   * so you do not have to manually call `waitUntil()` on the event.\n   *\n   * @param {Request|string} input The request or URL to fetch and cache.\n   * @return {Promise<Response>}\n   */\n  async fetchAndCachePut(input) {\n    const response = await this.fetch(input);\n    const responseClone = response.clone();\n    void this.waitUntil(this.cachePut(input, responseClone));\n    return response;\n  }\n  /**\n   * Matches a request from the cache (and invokes any applicable plugin\n   * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n   * defined on the strategy object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - cacheKeyWillByUsed()\n   * - cachedResponseWillByUsed()\n   *\n   * @param {Request|string} key The Request or URL to use as the cache key.\n   * @return {Promise<Response|undefined>} A matching response, if found.\n   */\n  async cacheMatch(key) {\n    const request = toRequest(key);\n    let cachedResponse;\n    const {\n      cacheName,\n      matchOptions\n    } = this._strategy;\n    const effectiveRequest = await this.getCacheKey(request, 'read');\n    const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), {\n      cacheName\n    });\n    cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n    if (process.env.NODE_ENV !== 'production') {\n      if (cachedResponse) {\n        logger.debug(\"Found a cached response in '\".concat(cacheName, \"'.\"));\n      } else {\n        logger.debug(\"No cached response found in '\".concat(cacheName, \"'.\"));\n      }\n    }\n    for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n      cachedResponse = (await callback({\n        cacheName,\n        matchOptions,\n        cachedResponse,\n        request: effectiveRequest,\n        event: this.event\n      })) || undefined;\n    }\n    return cachedResponse;\n  }\n  /**\n   * Puts a request/response pair in the cache (and invokes any applicable\n   * plugin callback methods) using the `cacheName` and `plugins` defined on\n   * the strategy object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - cacheKeyWillByUsed()\n   * - cacheWillUpdate()\n   * - cacheDidUpdate()\n   *\n   * @param {Request|string} key The request or URL to use as the cache key.\n   * @param {Response} response The response to cache.\n   * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n   * not be cached, and `true` otherwise.\n   */\n  async cachePut(key, response) {\n    const request = toRequest(key);\n    // Run in the next task to avoid blocking other cache reads.\n    // https://github.com/w3c/ServiceWorker/issues/1397\n    await timeout(0);\n    const effectiveRequest = await this.getCacheKey(request, 'write');\n    if (process.env.NODE_ENV !== 'production') {\n      if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n        throw new WorkboxError('attempt-to-cache-non-get-request', {\n          url: getFriendlyURL(effectiveRequest.url),\n          method: effectiveRequest.method\n        });\n      }\n      // See https://github.com/GoogleChrome/workbox/issues/2818\n      const vary = response.headers.get('Vary');\n      if (vary) {\n        logger.debug(\"The response for \".concat(getFriendlyURL(effectiveRequest.url), \" \") + \"has a 'Vary: \".concat(vary, \"' header. \") + \"Consider setting the {ignoreVary: true} option on your strategy \" + \"to ensure cache matching and deletion works as expected.\");\n      }\n    }\n    if (!response) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.error(\"Cannot cache non-existent response for \" + \"'\".concat(getFriendlyURL(effectiveRequest.url), \"'.\"));\n      }\n      throw new WorkboxError('cache-put-with-no-response', {\n        url: getFriendlyURL(effectiveRequest.url)\n      });\n    }\n    const responseToCache = await this._ensureResponseSafeToCache(response);\n    if (!responseToCache) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\"Response '\".concat(getFriendlyURL(effectiveRequest.url), \"' \") + \"will not be cached.\", responseToCache);\n      }\n      return false;\n    }\n    const {\n      cacheName,\n      matchOptions\n    } = this._strategy;\n    const cache = await self.caches.open(cacheName);\n    const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n    const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\n    // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n    // feature. Consider into ways to only add this behavior if using\n    // precaching.\n    cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) : null;\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(\"Updating the '\".concat(cacheName, \"' cache with a new Response \") + \"for \".concat(getFriendlyURL(effectiveRequest.url), \".\"));\n    }\n    try {\n      await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n    } catch (error) {\n      if (error instanceof Error) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n        if (error.name === 'QuotaExceededError') {\n          await executeQuotaErrorCallbacks();\n        }\n        throw error;\n      }\n    }\n    for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n      await callback({\n        cacheName,\n        oldResponse,\n        newResponse: responseToCache.clone(),\n        request: effectiveRequest,\n        event: this.event\n      });\n    }\n    return true;\n  }\n  /**\n   * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n   * executes any of those callbacks found in sequence. The final `Request`\n   * object returned by the last plugin is treated as the cache key for cache\n   * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n   * been registered, the passed request is returned unmodified\n   *\n   * @param {Request} request\n   * @param {string} mode\n   * @return {Promise<Request>}\n   */\n  async getCacheKey(request, mode) {\n    const key = \"\".concat(request.url, \" | \").concat(mode);\n    if (!this._cacheKeys[key]) {\n      let effectiveRequest = request;\n      for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n        effectiveRequest = toRequest(await callback({\n          mode,\n          request: effectiveRequest,\n          event: this.event,\n          // params has a type any can't change right now.\n          params: this.params // eslint-disable-line\n        }));\n      }\n\n      this._cacheKeys[key] = effectiveRequest;\n    }\n    return this._cacheKeys[key];\n  }\n  /**\n   * Returns true if the strategy has at least one plugin with the given\n   * callback.\n   *\n   * @param {string} name The name of the callback to check for.\n   * @return {boolean}\n   */\n  hasCallback(name) {\n    for (const plugin of this._strategy.plugins) {\n      if (name in plugin) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Runs all plugin callbacks matching the given name, in order, passing the\n   * given param object (merged ith the current plugin state) as the only\n   * argument.\n   *\n   * Note: since this method runs all plugins, it's not suitable for cases\n   * where the return value of a callback needs to be applied prior to calling\n   * the next callback. See\n   * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n   * below for how to handle that case.\n   *\n   * @param {string} name The name of the callback to run within each plugin.\n   * @param {Object} param The object to pass as the first (and only) param\n   *     when executing each callback. This object will be merged with the\n   *     current plugin state prior to callback execution.\n   */\n  async runCallbacks(name, param) {\n    for (const callback of this.iterateCallbacks(name)) {\n      // TODO(philipwalton): not sure why `any` is needed. It seems like\n      // this should work with `as WorkboxPluginCallbackParam[C]`.\n      await callback(param);\n    }\n  }\n  /**\n   * Accepts a callback and returns an iterable of matching plugin callbacks,\n   * where each callback is wrapped with the current handler state (i.e. when\n   * you call each callback, whatever object parameter you pass it will\n   * be merged with the plugin's current state).\n   *\n   * @param {string} name The name fo the callback to run\n   * @return {Array<Function>}\n   */\n  *iterateCallbacks(name) {\n    for (const plugin of this._strategy.plugins) {\n      if (typeof plugin[name] === 'function') {\n        const state = this._pluginStateMap.get(plugin);\n        const statefulCallback = param => {\n          const statefulParam = Object.assign(Object.assign({}, param), {\n            state\n          });\n          // TODO(philipwalton): not sure why `any` is needed. It seems like\n          // this should work with `as WorkboxPluginCallbackParam[C]`.\n          return plugin[name](statefulParam);\n        };\n        yield statefulCallback;\n      }\n    }\n  }\n  /**\n   * Adds a promise to the\n   * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n   * of the event event associated with the request being handled (usually a\n   * `FetchEvent`).\n   *\n   * Note: you can await\n   * {@link workbox-strategies.StrategyHandler~doneWaiting}\n   * to know when all added promises have settled.\n   *\n   * @param {Promise} promise A promise to add to the extend lifetime promises\n   *     of the event that triggered the request.\n   */\n  waitUntil(promise) {\n    this._extendLifetimePromises.push(promise);\n    return promise;\n  }\n  /**\n   * Returns a promise that resolves once all promises passed to\n   * {@link workbox-strategies.StrategyHandler~waitUntil}\n   * have settled.\n   *\n   * Note: any work done after `doneWaiting()` settles should be manually\n   * passed to an event's `waitUntil()` method (not this handler's\n   * `waitUntil()` method), otherwise the service worker thread my be killed\n   * prior to your work completing.\n   */\n  async doneWaiting() {\n    let promise;\n    while (promise = this._extendLifetimePromises.shift()) {\n      await promise;\n    }\n  }\n  /**\n   * Stops running the strategy and immediately resolves any pending\n   * `waitUntil()` promises.\n   */\n  destroy() {\n    this._handlerDeferred.resolve(null);\n  }\n  /**\n   * This method will call cacheWillUpdate on the available plugins (or use\n   * status === 200) to determine if the Response is safe and valid to cache.\n   *\n   * @param {Request} options.request\n   * @param {Response} options.response\n   * @return {Promise<Response|undefined>}\n   *\n   * @private\n   */\n  async _ensureResponseSafeToCache(response) {\n    let responseToCache = response;\n    let pluginsUsed = false;\n    for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n      responseToCache = (await callback({\n        request: this.request,\n        response: responseToCache,\n        event: this.event\n      })) || undefined;\n      pluginsUsed = true;\n      if (!responseToCache) {\n        break;\n      }\n    }\n    if (!pluginsUsed) {\n      if (responseToCache && responseToCache.status !== 200) {\n        responseToCache = undefined;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (responseToCache) {\n          if (responseToCache.status !== 200) {\n            if (responseToCache.status === 0) {\n              logger.warn(\"The response for '\".concat(this.request.url, \"' \") + \"is an opaque response. The caching strategy that you're \" + \"using will not cache opaque responses by default.\");\n            } else {\n              logger.debug(\"The response for '\".concat(this.request.url, \"' \") + \"returned a status code of '\".concat(response.status, \"' and won't \") + \"be cached as a result.\");\n            }\n          }\n        }\n      }\n    }\n    return responseToCache;\n  }\n}\nexport { StrategyHandler };","map":{"version":3,"names":["assert","cacheMatchIgnoreParams","Deferred","executeQuotaErrorCallbacks","getFriendlyURL","logger","timeout","WorkboxError","toRequest","input","Request","StrategyHandler","constructor","strategy","options","_cacheKeys","process","env","NODE_ENV","isInstance","event","ExtendableEvent","moduleName","className","funcName","paramName","Object","assign","_strategy","_handlerDeferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","Map","plugin","set","waitUntil","promise","fetch","request","mode","FetchEvent","preloadResponse","possiblePreloadResponse","log","concat","url","originalRequest","hasCallback","clone","cb","iterateCallbacks","err","Error","thrownErrorMessage","message","pluginFilteredRequest","fetchResponse","undefined","fetchOptions","debug","status","callback","response","error","runCallbacks","fetchAndCachePut","responseClone","cachePut","cacheMatch","key","cachedResponse","cacheName","matchOptions","effectiveRequest","getCacheKey","multiMatchOptions","caches","match","method","vary","headers","get","responseToCache","_ensureResponseSafeToCache","cache","self","open","hasCacheUpdateCallback","oldResponse","put","name","newResponse","params","param","state","statefulCallback","statefulParam","push","doneWaiting","shift","destroy","resolve","pluginsUsed","warn"],"sources":["C:/Users/meyer/Documents/careerfoundry/meet/node_modules/workbox-strategies/StrategyHandler.js"],"sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * {@link workbox-strategies.Strategy~handle} or\n * {@link workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params] The return value from the\n     *     {@link workbox-routing~matchCallback} (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * {@link workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` (for non-navigation requests) and\n     * `plugins` defined on the `Strategy` object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === 'navigate' &&\n            event instanceof FetchEvent &&\n            event.preloadResponse) {\n            const possiblePreloadResponse = (await event.preloadResponse);\n            if (possiblePreloadResponse) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log(`Using a preloaded navigation response for ` +\n                        `'${getFriendlyURL(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        // If there is a fetchDidFail plugin, we need to save a clone of the\n        // original request before it's either modified by a requestWillFetch\n        // plugin or before the original request's body is consumed via fetch().\n        const originalRequest = this.hasCallback('fetchDidFail')\n            ? request.clone()\n            : null;\n        try {\n            for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                request = await cb({ request: request.clone(), event });\n            }\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownErrorMessage: err.message,\n                });\n            }\n        }\n        // The request can be altered by plugins with `requestWillFetch` making\n        // the original request (most likely from a `fetch` event) different\n        // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            // See https://github.com/GoogleChrome/workbox/issues/1796\n            fetchResponse = await fetch(request, request.mode === 'navigate' ? undefined : this._strategy.fetchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' returned a response with ` +\n                    `status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse,\n                });\n            }\n            return fetchResponse;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.log(`Network request for ` +\n                    `'${getFriendlyURL(request.url)}' threw an error.`, error);\n            }\n            // `originalRequest` will only exist if a `fetchDidFail` callback\n            // is being used (see above).\n            if (originalRequest) {\n                await this.runCallbacks('fetchDidFail', {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone(),\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, 'read');\n        const multiMatchOptions = Object.assign(Object.assign({}, matchOptions), { cacheName });\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (process.env.NODE_ENV !== 'production') {\n            if (cachedResponse) {\n                logger.debug(`Found a cached response in '${cacheName}'.`);\n            }\n            else {\n                logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n            cachedResponse =\n                (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n        }\n        return cachedResponse;\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Response} response The response to cache.\n     * @return {Promise<boolean>} `false` if a cacheWillUpdate caused the response\n     * not be cached, and `true` otherwise.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n            // See https://github.com/GoogleChrome/workbox/issues/2818\n            const vary = response.headers.get('Vary');\n            if (vary) {\n                logger.debug(`The response for ${getFriendlyURL(effectiveRequest.url)} ` +\n                    `has a 'Vary: ${vary}' header. ` +\n                    `Consider setting the {ignoreVary: true} option on your strategy ` +\n                    `to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback\n            ? await cacheMatchIgnoreParams(\n            // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n            // feature. Consider into ways to only add this behavior if using\n            // precaching.\n            cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions)\n            : null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n                if (error.name === 'QuotaExceededError') {\n                    await executeQuotaErrorCallbacks();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n        return true;\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    // params has a type any can't change right now.\n                    params: this.params, // eslint-disable-line\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * {@link workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = Object.assign(Object.assign({}, param), { state });\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * {@link workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * {@link workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while ((promise = this._extendLifetimePromises.shift())) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache =\n                (await callback({\n                    request: this.request,\n                    response: responseToCache,\n                    event: this.event,\n                })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}