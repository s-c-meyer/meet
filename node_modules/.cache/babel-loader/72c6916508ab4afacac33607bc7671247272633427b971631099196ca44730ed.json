{"ast":null,"code":"/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n  /**\n   *\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to the cache names provided by\n   * {@link workbox-core.cacheNames}.\n   * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n   * to use in conjunction with this caching strategy.\n   * @param {Object} [options.fetchOptions] Values passed along to the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n   * of all fetch() requests made by this strategy.\n   * @param {Object} [options.matchOptions] The\n   * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n   * for any `cache.match()` or `cache.put()` calls made by this strategy.\n   * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n   * get the response from the network if there's a precache miss.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n    super(options);\n    this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n    // Redirected responses cannot be used to satisfy a navigation request, so\n    // any redirected response must be \"copied\" rather than cloned, so the new\n    // response doesn't contain the `redirected` flag. See:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n    this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n  }\n  /**\n   * @private\n   * @param {Request|string} request A request to run this strategy for.\n   * @param {workbox-strategies.StrategyHandler} handler The event that\n   *     triggered the request.\n   * @return {Promise<Response>}\n   */\n  async _handle(request, handler) {\n    const response = await handler.cacheMatch(request);\n    if (response) {\n      return response;\n    }\n    // If this is an `install` event for an entry that isn't already cached,\n    // then populate the cache.\n    if (handler.event && handler.event.type === 'install') {\n      return await this._handleInstall(request, handler);\n    }\n    // Getting here means something went wrong. An entry that should have been\n    // precached wasn't found in the cache.\n    return await this._handleFetch(request, handler);\n  }\n  async _handleFetch(request, handler) {\n    let response;\n    const params = handler.params || {};\n    // Fall back to the network if we're configured to do so.\n    if (this._fallbackToNetwork) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.warn(\"The precached response for \" + \"\".concat(getFriendlyURL(request.url), \" in \").concat(this.cacheName, \" was not \") + \"found. Falling back to the network.\");\n      }\n      const integrityInManifest = params.integrity;\n      const integrityInRequest = request.integrity;\n      const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n      // Do not add integrity if the original request is no-cors\n      // See https://github.com/GoogleChrome/workbox/issues/3096\n      response = await handler.fetch(new Request(request, {\n        integrity: request.mode !== 'no-cors' ? integrityInRequest || integrityInManifest : undefined\n      }));\n      // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n      // that the response matches the precache manifest's expectations,\n      // and there's either a) no integrity property in the incoming request\n      // or b) there is an integrity, and it matches the precache manifest.\n      // See https://github.com/GoogleChrome/workbox/issues/2858\n      // Also if the original request users no-cors we don't use integrity.\n      // See https://github.com/GoogleChrome/workbox/issues/3096\n      if (integrityInManifest && noIntegrityConflict && request.mode !== 'no-cors') {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (process.env.NODE_ENV !== 'production') {\n          if (wasCached) {\n            logger.log(\"A response for \".concat(getFriendlyURL(request.url), \" \") + \"was used to \\\"repair\\\" the precache.\");\n          }\n        }\n      }\n    } else {\n      // This shouldn't normally happen, but there are edge cases:\n      // https://github.com/GoogleChrome/workbox/issues/1441\n      throw new WorkboxError('missing-precache-entry', {\n        cacheName: this.cacheName,\n        url: request.url\n      });\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n      // Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(\"Precaching is responding to: \" + getFriendlyURL(request.url));\n      logger.log(\"Serving the precached url: \".concat(getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)));\n      logger.groupCollapsed(\"View request details here.\");\n      logger.log(request);\n      logger.groupEnd();\n      logger.groupCollapsed(\"View response details here.\");\n      logger.log(response);\n      logger.groupEnd();\n      logger.groupEnd();\n    }\n    return response;\n  }\n  async _handleInstall(request, handler) {\n    this._useDefaultCacheabilityPluginIfNeeded();\n    const response = await handler.fetch(request);\n    // Make sure we defer cachePut() until after we know the response\n    // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n    const wasCached = await handler.cachePut(request, response.clone());\n    if (!wasCached) {\n      // Throwing here will lead to the `install` handler failing, which\n      // we want to do if *any* of the responses aren't safe to cache.\n      throw new WorkboxError('bad-precaching-response', {\n        url: request.url,\n        status: response.status\n      });\n    }\n    return response;\n  }\n  /**\n   * This method is complex, as there a number of things to account for:\n   *\n   * The `plugins` array can be set at construction, and/or it might be added to\n   * to at any time before the strategy is used.\n   *\n   * At the time the strategy is used (i.e. during an `install` event), there\n   * needs to be at least one plugin that implements `cacheWillUpdate` in the\n   * array, other than `copyRedirectedCacheableResponsesPlugin`.\n   *\n   * - If this method is called and there are no suitable `cacheWillUpdate`\n   * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n   *\n   * - If this method is called and there is exactly one `cacheWillUpdate`, then\n   * we don't have to do anything (this might be a previously added\n   * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n   *\n   * - If this method is called and there is more than one `cacheWillUpdate`,\n   * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n   * we need to remove it. (This situation is unlikely, but it could happen if\n   * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n   * and then later on after manually adding a custom `cacheWillUpdate`.)\n   *\n   * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n   *\n   * @private\n   */\n  _useDefaultCacheabilityPluginIfNeeded() {\n    let defaultPluginIndex = null;\n    let cacheWillUpdatePluginCount = 0;\n    for (const [index, plugin] of this.plugins.entries()) {\n      // Ignore the copy redirected plugin when determining what to do.\n      if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n        continue;\n      }\n      // Save the default plugin's index, in case it needs to be removed.\n      if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n        defaultPluginIndex = index;\n      }\n      if (plugin.cacheWillUpdate) {\n        cacheWillUpdatePluginCount++;\n      }\n    }\n    if (cacheWillUpdatePluginCount === 0) {\n      this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n    } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n      // Only remove the default plugin; multiple custom plugins are allowed.\n      this.plugins.splice(defaultPluginIndex, 1);\n    }\n    // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n  }\n}\n\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n  async cacheWillUpdate(_ref) {\n    let {\n      response\n    } = _ref;\n    if (!response || response.status >= 400) {\n      return null;\n    }\n    return response;\n  }\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n  async cacheWillUpdate(_ref2) {\n    let {\n      response\n    } = _ref2;\n    return response.redirected ? await copyResponse(response) : response;\n  }\n};\nexport { PrecacheStrategy };","map":{"version":3,"names":["copyResponse","cacheNames","getFriendlyURL","logger","WorkboxError","Strategy","PrecacheStrategy","constructor","options","arguments","length","undefined","cacheName","getPrecacheName","_fallbackToNetwork","fallbackToNetwork","plugins","push","copyRedirectedCacheableResponsesPlugin","_handle","request","handler","response","cacheMatch","event","type","_handleInstall","_handleFetch","params","process","env","NODE_ENV","warn","concat","url","integrityInManifest","integrity","integrityInRequest","noIntegrityConflict","fetch","Request","mode","_useDefaultCacheabilityPluginIfNeeded","wasCached","cachePut","clone","log","cacheKey","getCacheKey","groupCollapsed","groupEnd","status","defaultPluginIndex","cacheWillUpdatePluginCount","index","plugin","entries","defaultPrecacheCacheabilityPlugin","cacheWillUpdate","splice","_ref","_ref2","redirected"],"sources":["C:/Users/meyer/Documents/careerfoundry/meet/node_modules/workbox-precaching/PrecacheStrategy.js"],"sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { copyResponse } from 'workbox-core/copyResponse.js';\nimport { cacheNames } from 'workbox-core/_private/cacheNames.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport { Strategy } from 'workbox-strategies/Strategy.js';\nimport './_version.js';\n/**\n * A {@link workbox-strategies.Strategy} implementation\n * specifically designed to work with\n * {@link workbox-precaching.PrecacheController}\n * to both cache and fetch precached assets.\n *\n * Note: an instance of this class is created automatically when creating a\n * `PrecacheController`; it's generally not necessary to create this yourself.\n *\n * @extends workbox-strategies.Strategy\n * @memberof workbox-precaching\n */\nclass PrecacheStrategy extends Strategy {\n    /**\n     *\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to the cache names provided by\n     * {@link workbox-core.cacheNames}.\n     * @param {Array<Object>} [options.plugins] {@link https://developers.google.com/web/tools/workbox/guides/using-plugins|Plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} [options.fetchOptions] Values passed along to the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters|init}\n     * of all fetch() requests made by this strategy.\n     * @param {Object} [options.matchOptions] The\n     * {@link https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions|CacheQueryOptions}\n     * for any `cache.match()` or `cache.put()` calls made by this strategy.\n     * @param {boolean} [options.fallbackToNetwork=true] Whether to attempt to\n     * get the response from the network if there's a precache miss.\n     */\n    constructor(options = {}) {\n        options.cacheName = cacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork =\n            options.fallbackToNetwork === false ? false : true;\n        // Redirected responses cannot be used to satisfy a navigation request, so\n        // any redirected response must be \"copied\" rather than cloned, so the new\n        // response doesn't contain the `redirected` flag. See:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=669363&desc=2#c1\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    /**\n     * @private\n     * @param {Request|string} request A request to run this strategy for.\n     * @param {workbox-strategies.StrategyHandler} handler The event that\n     *     triggered the request.\n     * @return {Promise<Response>}\n     */\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        // If this is an `install` event for an entry that isn't already cached,\n        // then populate the cache.\n        if (handler.event && handler.event.type === 'install') {\n            return await this._handleInstall(request, handler);\n        }\n        // Getting here means something went wrong. An entry that should have been\n        // precached wasn't found in the cache.\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response;\n        const params = (handler.params || {});\n        // Fall back to the network if we're configured to do so.\n        if (this._fallbackToNetwork) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.warn(`The precached response for ` +\n                    `${getFriendlyURL(request.url)} in ${this.cacheName} was not ` +\n                    `found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            // Do not add integrity if the original request is no-cors\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== 'no-cors'\n                    ? integrityInRequest || integrityInManifest\n                    : undefined,\n            }));\n            // It's only \"safe\" to repair the cache if we're using SRI to guarantee\n            // that the response matches the precache manifest's expectations,\n            // and there's either a) no integrity property in the incoming request\n            // or b) there is an integrity, and it matches the precache manifest.\n            // See https://github.com/GoogleChrome/workbox/issues/2858\n            // Also if the original request users no-cors we don't use integrity.\n            // See https://github.com/GoogleChrome/workbox/issues/3096\n            if (integrityInManifest &&\n                noIntegrityConflict &&\n                request.mode !== 'no-cors') {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (process.env.NODE_ENV !== 'production') {\n                    if (wasCached) {\n                        logger.log(`A response for ${getFriendlyURL(request.url)} ` +\n                            `was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        }\n        else {\n            // This shouldn't normally happen, but there are edge cases:\n            // https://github.com/GoogleChrome/workbox/issues/1441\n            throw new WorkboxError('missing-precache-entry', {\n                cacheName: this.cacheName,\n                url: request.url,\n            });\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const cacheKey = params.cacheKey || (await handler.getCacheKey(request, 'read'));\n            // Workbox is going to handle the route.\n            // print the routing details to the console.\n            logger.groupCollapsed(`Precaching is responding to: ` + getFriendlyURL(request.url));\n            logger.log(`Serving the precached url: ${getFriendlyURL(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            logger.groupCollapsed(`View request details here.`);\n            logger.log(request);\n            logger.groupEnd();\n            logger.groupCollapsed(`View response details here.`);\n            logger.log(response);\n            logger.groupEnd();\n            logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        // Make sure we defer cachePut() until after we know the response\n        // should be cached; see https://github.com/GoogleChrome/workbox/issues/2737\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            // Throwing here will lead to the `install` handler failing, which\n            // we want to do if *any* of the responses aren't safe to cache.\n            throw new WorkboxError('bad-precaching-response', {\n                url: request.url,\n                status: response.status,\n            });\n        }\n        return response;\n    }\n    /**\n     * This method is complex, as there a number of things to account for:\n     *\n     * The `plugins` array can be set at construction, and/or it might be added to\n     * to at any time before the strategy is used.\n     *\n     * At the time the strategy is used (i.e. during an `install` event), there\n     * needs to be at least one plugin that implements `cacheWillUpdate` in the\n     * array, other than `copyRedirectedCacheableResponsesPlugin`.\n     *\n     * - If this method is called and there are no suitable `cacheWillUpdate`\n     * plugins, we need to add `defaultPrecacheCacheabilityPlugin`.\n     *\n     * - If this method is called and there is exactly one `cacheWillUpdate`, then\n     * we don't have to do anything (this might be a previously added\n     * `defaultPrecacheCacheabilityPlugin`, or it might be a custom plugin).\n     *\n     * - If this method is called and there is more than one `cacheWillUpdate`,\n     * then we need to check if one is `defaultPrecacheCacheabilityPlugin`. If so,\n     * we need to remove it. (This situation is unlikely, but it could happen if\n     * the strategy is used multiple times, the first without a `cacheWillUpdate`,\n     * and then later on after manually adding a custom `cacheWillUpdate`.)\n     *\n     * See https://github.com/GoogleChrome/workbox/issues/2737 for more context.\n     *\n     * @private\n     */\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()) {\n            // Ignore the copy redirected plugin when determining what to do.\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            // Save the default plugin's index, in case it needs to be removed.\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        }\n        else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            // Only remove the default plugin; multiple custom plugins are allowed.\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n        // Nothing needs to be done if cacheWillUpdatePluginCount is 1\n    }\n}\nPrecacheStrategy.defaultPrecacheCacheabilityPlugin = {\n    async cacheWillUpdate({ response }) {\n        if (!response || response.status >= 400) {\n            return null;\n        }\n        return response;\n    },\n};\nPrecacheStrategy.copyRedirectedCacheableResponsesPlugin = {\n    async cacheWillUpdate({ response }) {\n        return response.redirected ? await copyResponse(response) : response;\n    },\n};\nexport { PrecacheStrategy };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}